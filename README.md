# Distributed Leader-Follower Database

Simple, persistent, distributed database implementation with leader-follower replication and automatic leader election (Bully algorithm)

- [Leader-follower architecture](https://www.educative.io/answers/leader-and-follower-replication) for data replication
- [Bully algorithm](https://www.educative.io/answers/what-is-a-bully-election-algorithm) for leader election
- [Write-ahead logging (WAL)](https://www.educative.io/answers/what-is-the-write-ahead-log) for durability 
- Real-time metrics dashboard
- REST API endpoints using [FastAPI](https://fastapi.tiangolo.com/)

I got this idea after reading through the [Designing Data-Intensive Applications](https://dataintensive.net/) book

## Architecture

The database consists of multiple nodes where one acts as a leader (accepting writes) and others as followers 

The leader handles all write operations and replicates data to followers. 

If the leader fails, remaining nodes elect a new leader using the Bully algorithm.

The in-memory data is ocassionally written out on-disk for persistence, and recovers from crashes using the WAL

### Components
- **Node Class**: Core component managing state, replication, and leader election
- **WAL**: Write-ahead log for crash recovery
- **REST API**: FastAPI endpoints for reads/writes
- **React Dashboard**: Real-time monitoring of node status

### Replication
1. Client sends write request to leader
2. Leader appends to WAL
3. Leader updates its local store
4. Leader replicates to followers
5. Followers update their stores

## Stack

- Backend: Python, FastAPI, asyncio
- Frontend: React
- Storage: File-based (JSON + WAL)
- Communication: REST API

## How to Use

### Prerequisites
```bash
pip3 install requirements.txt
npm install # for UI dependencies
```

### Running the Cluster
As a convenience, you can run `start.sh` to automatically start 3 clusters (1 leader and 2 followers) running on local ports

This can be edited to configure the system as you'd like.

Alternatively, you can run the `db.py` module directly as separate processes/terminals:

```bash
python3 db.py --role leader --port 8000 --peers 8001
python3 db.py --role follower --port 8001 --peers 8000
```

### Running the UI
```bash
cd metrics-ui
npm run dev
```

### API Endpoints
Once the cluster is running, you can visit http://url:port>/docs/ (for example, http://localhost:8000/docs/) to see a comprehensive list of the API (generated by FastAPI):

<img width="1728" alt="Screenshot 2025-02-04 at 5 26 21 PM" src="https://github.com/user-attachments/assets/886aa308-916f-48e1-95d3-e3bb7b475cb1" />

This is a short description of the functionality if you don't have the cluster running:

`POST /write` - Write key-value pair

`GET /read/{key}` - Read value by key

`GET /metrics` - Node metrics

`GET /health` - Node health status

`POST /replicate` (internal) - Used for Node replication

`POST /new_leader` (internal) - Used for electing a new Node leader

### UI
Short demo of the UI (GitHub limits the length of video). The UI is very simple and mainly helped me debug 

Planning on adding additional functionality like adding new nodes and killing nodes to show leader election.

For now it's very simple, and the ports are hardcoded (so you'll need to change which ports are being looked at depending on how you set up the cluster). 

https://github.com/user-attachments/assets/b16b65ad-b6d2-463f-afa5-f107301100a7

